-- Auto Defuse Script
-- Upload this to GitHub and use the raw link

Print("kys")

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer

-- Get settings from global
local AutoDefuseSettings = getgenv().AutoDefuseSettings
if not AutoDefuseSettings then
    warn("AutoDefuseSettings not found - load Combat GUI first")
    return
end

-- Target animation IDs
local DEFUSE_ANIMATION_IDS = {
    "99918936475651",
    "115241304811827"
}

local detectionCircles = {} -- Store circles for each character
local monitoredCharacters = {} -- Track all characters
local nearbyCharacters = {} -- Only characters within 70 studs
local checkedAnimations = {} -- Track animations we've already detected
local lastRadius = 30 -- Cache last radius to detect changes

-- Check if character is in Monsters team
local function isMonstersTeam(character)
    local player = Players:GetPlayerFromCharacter(character)
    if not player or not player.Team then return false end
    return player.Team.Name == "Monsters"
end

-- Check if animation ID matches defuse animations
local function isDefuseAnimation(numericId)
    if not numericId then return false end
    
    for _, targetId in pairs(DEFUSE_ANIMATION_IDS) do
        if numericId == targetId then
            return true
        end
    end
    return false
end

-- Get distance from local player
local function getDistance(character)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return math.huge
    end
    
    local targetHRP = character:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return math.huge end
    
    return (LocalPlayer.Character.HumanoidRootPart.Position - targetHRP.Position).Magnitude
end

-- Update nearby characters list (every 3 seconds)
local function updateNearbyCharacters()
    local newNearby = {}
    
    for character, _ in pairs(monitoredCharacters) do
        if character and character.Parent then
            local distance = getDistance(character)
            
            -- Only track characters within 70 studs
            if distance <= 70 then
                newNearby[character] = true
            else
                -- Remove circle if character is too far
                removeDetectionCircle(character)
            end
        end
    end
    
    nearbyCharacters = newNearby
end

-- Create simple circle using mesh
local function createDetectionCircle(character)
    if detectionCircles[character] then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local radius = AutoDefuseSettings.DetectionRadius or 30
    
    -- Create circle part with mesh
    local circle = Instance.new("Part")
    circle.Name = "DetectionCircle"
    circle.Size = Vector3.new(radius * 2, 0.2, radius * 2)
    circle.Anchored = true
    circle.CanCollide = false
    circle.Material = Enum.Material.SmoothPlastic
    circle.Transparency = 1 -- Make part invisible
    circle.CFrame = hrp.CFrame * CFrame.Angles(math.rad(90), 0, 0) -- Rotate to lay flat
    circle.Parent = Workspace
    
    -- Add mesh
    local mesh = Instance.new("SpecialMesh")
    mesh.MeshType = Enum.MeshType.FileMesh
    mesh.MeshId = "rbxassetid://125071719379373"
    mesh.Scale = Vector3.new(radius * 2, radius * 2, radius * 2)
    mesh.Parent = circle
    
    detectionCircles[character] = circle
end

-- Remove detection circle
local function removeDetectionCircle(character)
    if detectionCircles[character] then
        detectionCircles[character]:Destroy()
        detectionCircles[character] = nil
    end
end

-- Update circle colors and position (only for nearby characters)
local function updateCircles()
    local radius = AutoDefuseSettings.DetectionRadius or 30
    
    -- Only recreate circles if radius changed
    if radius ~= lastRadius then
        for character, _ in pairs(detectionCircles) do
            removeDetectionCircle(character)
        end
        lastRadius = radius
    end
    
    -- Manage circle visibility (only for nearby characters)
    if AutoDefuseSettings.ShowCircle then
        -- Only process nearby characters
        for character, _ in pairs(nearbyCharacters) do
            if character and character.Parent then
                if isMonstersTeam(character) then
                    if not detectionCircles[character] then
                        createDetectionCircle(character)
                    end
                else
                    removeDetectionCircle(character)
                end
            end
        end
    else
        -- Remove all circles if disabled
        for character, _ in pairs(detectionCircles) do
            removeDetectionCircle(character)
        end
        return
    end
    
    -- Update existing circles (position and color only)
    for character, circle in pairs(detectionCircles) do
        if character and character.Parent and circle and circle.Parent then
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local distance = getDistance(character)
                local color = distance <= radius and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                
                -- Update color
                circle.Color = color
                
                -- Update position
                circle.CFrame = hrp.CFrame * CFrame.Angles(math.rad(90), 0, 0)
                
                -- Update size if radius changed
                circle.Size = Vector3.new(radius * 2, 0.2, radius * 2)
                local mesh = circle:FindFirstChildOfClass("SpecialMesh")
                if mesh then
                    mesh.Scale = Vector3.new(radius * 2, radius * 2, radius * 2)
                end
            end
        else
            if circle then circle:Destroy() end
            detectionCircles[character] = nil
        end
    end
end

-- Check for playing animations (only for nearby characters)
local function checkAnimations()
    -- Only check nearby characters
    for character, _ in pairs(nearbyCharacters) do
        if character and character.Parent then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local animator = humanoid:FindFirstChildOfClass("Animator")
                if animator then
                    local success, tracks = pcall(function()
                        return animator:GetPlayingAnimationTracks()
                    end)
                    
                    if success and tracks then
                        for _, track in ipairs(tracks) do
                            if track.IsPlaying and track.Animation then
                                local animId = track.Animation.AnimationId
                                local numericId = animId:match("%d+")
                                
                                if numericId and isDefuseAnimation(numericId) then
                                    local checkKey = character.Name .. "_" .. numericId .. "_" .. math.floor(track.TimePosition * 10)
                                    
                                    if not checkedAnimations[checkKey] then
                                        checkedAnimations[checkKey] = true
                                        
                                        print("Animation detected:", numericId, "from", character.Name)
                                        
                                        local radius = AutoDefuseSettings.DetectionRadius or 30
                                        local distance = getDistance(character)
                                        
                                        if distance <= radius then
                                            print("DEFUSE ANIMATION DETECTED!")
                                            print("Character:", character.Name)
                                            print("Distance:", math.floor(distance), "studs")
                                            
                                            local delayMs = AutoDefuseSettings.Delay or 3000
                                            print("Waiting", delayMs, "ms...")
                                            
                                            task.spawn(function()
                                                task.wait(delayMs / 1000)
                                                
                                                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                                                task.wait(0.05)
                                                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
                                                
                                                print("Defused! (Clicked)")
                                                
                                                task.wait(2)
                                                checkedAnimations[checkKey] = nil
                                            end)
                                        else
                                            print("Too far away:", math.floor(distance), "studs (need â‰¤" .. radius .. ")")
                                            task.wait(1)
                                            checkedAnimations[checkKey] = nil
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Hook a character
local function hookCharacter(character)
    if not AutoDefuseSettings.Enabled then return end
    monitoredCharacters[character] = true
    print("Monitoring character:", character.Name)
end

-- Start monitoring
local updateLoop = nil
local animLoop = nil
local distanceLoop = nil

local function startMonitoring()
    local characters = Workspace:FindFirstChild("Characters")
    
    if not characters then
        warn("Workspace.Characters not found! Looking in Workspace root instead...")
        characters = Workspace
    end
    
    for _, character in ipairs(characters:GetChildren()) do
        if character:IsA("Model") then
            task.spawn(function()
                hookCharacter(character)
            end)
        end
    end
    
    characters.ChildAdded:Connect(function(character)
        if not AutoDefuseSettings.Enabled then return end
        task.wait(0.1)
        if character:IsA("Model") then
            task.spawn(function()
                hookCharacter(character)
            end)
        end
    end)
    
    characters.ChildRemoved:Connect(function(character)
        monitoredCharacters[character] = nil
        nearbyCharacters[character] = nil
        removeDetectionCircle(character)
    end)
    
    -- Distance checks: Every 3 seconds
    distanceLoop = task.spawn(function()
        while AutoDefuseSettings.Enabled do
            pcall(updateNearbyCharacters)
            task.wait(3)
        end
    end)
    
    -- Circle updates: 30 FPS (0.033s)
    updateLoop = task.spawn(function()
        while AutoDefuseSettings.Enabled do
            pcall(updateCircles)
            task.wait(0.033)
        end
    end)
    
    -- Animation checks: 100 FPS (0.01s)
    animLoop = task.spawn(function()
        while AutoDefuseSettings.Enabled do
            pcall(checkAnimations)
            task.wait(0.01)
        end
    end)
    
    print("Auto Defuse enabled - Simple mesh circles")
    print("Target IDs:", table.concat(DEFUSE_ANIMATION_IDS, ", "))
    print("Detection Radius:", AutoDefuseSettings.DetectionRadius or 30, "studs")
    print("Max Range: 70 studs (checked every 3s)")
    print("Delay:", AutoDefuseSettings.Delay or 3000, "ms")
    print("Show Circle:", AutoDefuseSettings.ShowCircle and "Yes" or "No")
    print("Filter: Monsters team only")
end

local function stopMonitoring()
    if updateLoop then
        task.cancel(updateLoop)
        updateLoop = nil
    end
    
    if animLoop then
        task.cancel(animLoop)
        animLoop = nil
    end
    
    if distanceLoop then
        task.cancel(distanceLoop)
        distanceLoop = nil
    end
    
    for character, circle in pairs(detectionCircles) do
        circle:Destroy()
    end
    detectionCircles = {}
    monitoredCharacters = {}
    nearbyCharacters = {}
    checkedAnimations = {}
end

-- Export control functions
getgenv().AutoDefuseControl = {
    Start = function()
        AutoDefuseSettings.Enabled = true
        startMonitoring()
    end,
    Stop = function()
        AutoDefuseSettings.Enabled = false
        stopMonitoring()
        print("Auto Defuse disabled")
    end
}

print("Auto Defuse Script Loaded!")
return true
