-- AutoFarm v4
-- Goes straight to target (walks off cliffs, no edge avoidance)
-- Movement = XZ only (Y changes ignored)
-- Idle 5s = auto left click
-- Monsters: click within 30 studs, click if alive 20s without taking damage
-- Humans: press "1" once on monster detect, 30cps, anti-back, target memory, waypoint

print("rkerfkjewrkf")

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")
local VIS = game:GetService("VirtualInputManager")
local LP = Players.LocalPlayer

-- ========== CONFIG ==========
local JUMP_EVERY = 1
local PREDICT = 0.3
local Y_PENALTY = 3
local MAX_Y = 50
local JUMP_H = 8.5
local MAX_OBS = 9

local IDLE_TIME = 5
local IDLE_DIST = 1

local MONSTER_CLICK_RANGE = 30
local MONSTER_NODMG_TIME = 20

local HUMAN_CPS = 30
local HUMAN_DETECT_RANGE = 30

-- ========== STATE ==========
local running = false
local heartbeatConn = nil
local lastJump = 0
local lastClickTime = 0

-- idle (XZ only)
local idleXZ = nil
local idleTimer = 0

-- monsters
local monsterLastHP = nil
local monsterNoDmgStart = nil
local lastSpawnPress = 0

-- humans
local pressedOne = false
local memoryTarget = nil
local circlePart = nil

-- death tracking
local deathConn = nil
local charConn = nil

-- tools to repair after death
local REPAIR_TOOLS = {
    "WoodenSword", "StoneSword", "IronSword", "Bow",
    "GoldSword", "DiamondSword", "EmeraldAxe", "Trident", "ObsidianHammer"
}

-- pathfind (wall only)
local pfWaypoints = nil
local pfIndex = 2
local pfPath = nil
local pfKey = nil
local pfTime = 0
local pfBlockedConn = nil
local pfActive = false

-- ========== SETTINGS ==========
local function S()
    return getgenv().AutoFarmSettings or {}
end

-- ========== RAYCAST ==========
local rayP = RaycastParams.new()
rayP.FilterType = Enum.RaycastFilterType.Exclude

local function refreshRay()
    local t = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Character then t[#t + 1] = p.Character end
    end
    rayP.FilterDescendantsInstances = t
end

-- ========== CORE HELPERS ==========
local function root(p)
    local c = p.Character
    return c and c:FindFirstChild("HumanoidRootPart")
end

local function hum(p)
    local c = p.Character
    return c and c:FindFirstChildOfClass("Humanoid")
end

local function alive(p)
    local h = hum(p)
    return h and h.Health > 0
end

local function team(p)
    return p.Team and p.Team.Name
end

local function isMonster(p) return team(p) == "Monsters" end
local function isHuman(p) return team(p) == "Humans" end

local function dist3d(a, b)
    local ra, rb = root(a), root(b)
    if not ra or not rb then return math.huge end
    return (ra.Position - rb.Position).Magnitude
end

local function distPos(p, pos)
    local r = root(p)
    if not r then return math.huge end
    return (r.Position - pos).Magnitude
end

local function score(p)
    local a, b = root(LP), root(p)
    if not a or not b then return math.huge end
    local d = a.Position - b.Position
    local horiz = math.sqrt(d.X * d.X + d.Z * d.Z)
    local vert = math.abs(d.Y)
    if vert > MAX_Y then return math.huge end
    return horiz + vert * Y_PENALTY
end

local function predict(p)
    local r = root(p)
    if not r then return nil end
    local v = r.AssemblyLinearVelocity
    return r.Position + Vector3.new(v.X, 0, v.Z) * PREDICT
end

local function getVel(p)
    local r = root(p)
    if not r then return Vector3.zero end
    return r.AssemblyLinearVelocity
end

-- ========== INPUT ==========
local function click()
    pcall(function()
        mouse1press()
        task.defer(function() mouse1release() end)
    end)
end

local function tapKey(keyCode)
    pcall(function()
        VIS:SendKeyEvent(true, keyCode, false, game)
        task.defer(function()
            VIS:SendKeyEvent(false, keyCode, false, game)
        end)
    end)
end

-- ========== MOVEMENT ==========
local function moveTo(pos)
    local h = hum(LP)
    if h then h:MoveTo(pos) end
end

local function stopMov()
    local h, r = hum(LP), root(LP)
    if h and r then h:MoveTo(r.Position) end
end

local function face(tgt)
    local a, b = root(LP), root(tgt)
    if not a or not b then return end
    local d = b.Position - a.Position
    local flat = Vector3.new(d.X, 0, d.Z)
    if flat.Magnitude < 0.1 then return end
    a.CFrame = CFrame.lookAt(a.Position, a.Position + flat.Unit)
end

-- ========== JUMP ==========
local function jump()
    local h = hum(LP)
    if not h then return end
    h.JumpHeight = JUMP_H
    h.UseJumpPower = false
    local st = h:GetState()
    if st == Enum.HumanoidStateType.Running
        or st == Enum.HumanoidStateType.RunningNoPhysics
        or st == Enum.HumanoidStateType.Landed
        or st == Enum.HumanoidStateType.None then
        h:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end

local function tryJump()
    local now = tick()
    if now - lastJump >= JUMP_EVERY then
        jump()
        lastJump = now
    end
end

-- ========== OBSTACLE (wall in front) ==========
local function obsHeight()
    local r = root(LP)
    if not r then return 0 end
    refreshRay()
    local foot = r.Position - Vector3.new(0, 2.5, 0)
    local fwd = r.CFrame.LookVector * 4
    if not workspace:Raycast(foot, fwd, rayP) then return 0 end
    for i = 1, 16 do
        if not workspace:Raycast(foot + Vector3.new(0, i, 0), fwd, rayP) then
            return i
        end
    end
    return 99
end

local function sidestep()
    local r, h = root(LP), hum(LP)
    if not r or not h then return end
    refreshRay()
    local rH = workspace:Raycast(r.Position, r.CFrame.RightVector * 6, rayP)
    local lH = workspace:Raycast(r.Position, -r.CFrame.RightVector * 6, rayP)
    if not rH then
        h:MoveTo(r.Position + r.CFrame.RightVector * 5)
    elseif not lH then
        h:MoveTo(r.Position - r.CFrame.RightVector * 5)
    else
        jump()
    end
end

local function handleObs()
    local h = obsHeight()
    if h >= 2 and h <= MAX_OBS then
        jump()
    elseif h > MAX_OBS then
        sidestep()
    end
end

-- ========== WALL CHECK (no edge check) ==========
local function hasWall(targetPos)
    local r = root(LP)
    if not r then return false end
    refreshRay()
    local dir = targetPos - r.Position
    local flat = Vector3.new(dir.X, 0, dir.Z)
    if flat.Magnitude < 2 then return false end
    local d = math.min(flat.Magnitude, 30)
    local hit = workspace:Raycast(r.Position, flat.Unit * d, rayP)
    if not hit then return false end
    if hit.Normal.Y > 0.8 then return false end
    return true
end

-- ========== IDLE DETECTION (XZ ONLY, ignore Y) ==========
local function checkIdle(dt)
    local r = root(LP)
    if not r then return false end

    local xz = Vector2.new(r.Position.X, r.Position.Z)

    if idleXZ then
        local moved = (xz - idleXZ).Magnitude
        if moved < IDLE_DIST then
            idleTimer = idleTimer + dt
            if idleTimer >= IDLE_TIME then
                idleTimer = 0
                idleXZ = xz
                return true
            end
            idleXZ = xz
            return false
        end
    end

    -- moved: reset
    idleTimer = 0
    idleXZ = xz
    return false
end

-- ========== CIRCLE ==========
local function destroyCircle()
    if circlePart then
        pcall(function() circlePart:Destroy() end)
        circlePart = nil
    end
end

local function updateCircle()
    local s = S()
    if not s.ShowCircle or not running then
        destroyCircle()
        return
    end
    local r = root(LP)
    if not r then destroyCircle() return end
    local radius = s.DetectRadius or HUMAN_DETECT_RANGE
    if not circlePart or not circlePart.Parent then
        circlePart = Instance.new("Part")
        circlePart.Name = "AutoFarmCircle"
        circlePart.Shape = Enum.PartType.Cylinder
        circlePart.Anchored = true
        circlePart.CanCollide = false
        circlePart.Material = Enum.Material.ForceField
        circlePart.Transparency = 0.75
        circlePart.Parent = workspace
    end
    circlePart.Size = Vector3.new(0.1, radius * 2, radius * 2)
    circlePart.CFrame = CFrame.new(r.Position.X, r.Position.Y - 3, r.Position.Z) * CFrame.Angles(0, 0, math.rad(90))
    local found = false
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP and isMonster(p) and alive(p) and dist3d(LP, p) <= radius then
            found = true
            break
        end
    end
    circlePart.Color = found and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(200, 0, 0)
end

-- ========== PATHFIND (wall bypass only) ==========
local function clearPF()
    pfWaypoints = nil
    pfIndex = 2
    if pfBlockedConn then pcall(function() pfBlockedConn:Disconnect() end) pfBlockedConn = nil end
    pfPath = nil
    pfKey = nil
    pfActive = false
end

local function makePath(targetPos)
    local r = root(LP)
    if not r then return false end
    local path = PathfindingService:CreatePath({
        AgentRadius = 2, AgentHeight = 5,
        AgentCanJump = true, WaypointSpacing = 3
    })
    local ok = pcall(function() path:ComputeAsync(r.Position, targetPos) end)
    if not ok or path.Status ~= Enum.PathStatus.Success then return false end
    if pfBlockedConn then pcall(function() pfBlockedConn:Disconnect() end) end
    pfPath = path
    pfWaypoints = path:GetWaypoints()
    pfIndex = 2
    pfBlockedConn = path.Blocked:Connect(function() clearPF() end)
    return true
end

local function nextWP()
    if not pfWaypoints then return nil end
    while pfIndex <= #pfWaypoints do
        local wp = pfWaypoints[pfIndex]
        local r = root(LP)
        if not r then return nil end
        local toWp = wp.Position - r.Position
        local behind = (toWp.X * r.CFrame.LookVector.X + toWp.Z * r.CFrame.LookVector.Z) < -1
        if (r.Position - wp.Position).Magnitude < 3 or behind then
            pfIndex = pfIndex + 1
        else
            return wp
        end
    end
    clearPF()
    return nil
end

-- ========== GO TO (straight, pathfind only for walls) ==========
local function goTo(targetPos, key)
    local r = root(LP)
    if not r then return end

    -- currently pathfinding around wall
    if pfActive then
        if not hasWall(targetPos) then
            clearPF()
            moveTo(targetPos)
            handleObs()
            return
        end
        local now = tick()
        if not pfWaypoints or pfKey ~= key or now - pfTime > 1.5 then
            makePath(targetPos)
            pfKey = key
            pfTime = now
        end
        local wp = nextWP()
        if wp then
            if wp.Action == Enum.PathWaypointAction.Jump then jump() end
            handleObs()
            moveTo(wp.Position)
        else
            moveTo(targetPos)
            handleObs()
        end
        return
    end

    -- go straight (even off cliffs)
    if not hasWall(targetPos) then
        moveTo(targetPos)
        handleObs()
        return
    end

    -- wall: jumpable?
    local oh = obsHeight()
    if oh >= 2 and oh <= MAX_OBS then
        jump()
        moveTo(targetPos)
        return
    end

    -- tall wall: pathfind around
    pfActive = true
    if makePath(targetPos) then
        pfKey = key
        pfTime = tick()
    end
    local wp = nextWP()
    if wp then
        if wp.Action == Enum.PathWaypointAction.Jump then jump() end
        handleObs()
        moveTo(wp.Position)
    else
        sidestep()
    end
end

-- ========== TARGET FINDING ==========
local function findInRadius(radius)
    local my = team(LP)
    local best, bs = nil, math.huge
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP and alive(p) then
            local t = team(p)
            local ok = (my == "Monsters" and t == "Humans") or (my == "Humans" and t == "Monsters")
            if ok and dist3d(LP, p) <= radius then
                local s = score(p)
                if s < bs then best, bs = p, s end
            end
        end
    end
    return best
end

local function findAny()
    local my = team(LP)
    local best, bs = nil, math.huge
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP and alive(p) then
            local t = team(p)
            local ok = (my == "Monsters" and t == "Humans") or (my == "Humans" and t == "Monsters")
            if ok then
                local s = score(p)
                if s < bs then best, bs = p, s end
            end
        end
    end
    return best
end

local function movingAway(tgt)
    local a, b = root(LP), root(tgt)
    if not a or not b then return false end
    local toUs = (a.Position - b.Position).Unit
    local vel = getVel(tgt)
    local hv = Vector3.new(vel.X, 0, vel.Z)
    if hv.Magnitude < 2 then return false end
    return (toUs.X * hv.Unit.X + toUs.Z * hv.Unit.Z) < -0.3
end

-- ========== SPAWN BUTTON (Monsters) ==========
local function pressSpawnButton()
    pcall(function()
        local playerGui = LP:FindFirstChild("PlayerGui")
        if not playerGui then return end

        local buttons = {}
        for _, desc in ipairs(playerGui:GetDescendants()) do
            if desc.Name == "SpawnButtonTemplate" then
                local btn = desc:FindFirstChild("Button")
                if btn and btn:IsA("GuiButton") and btn.Visible then
                    buttons[#buttons + 1] = btn
                end
            end
        end

        if #buttons > 0 then
            local pick = buttons[math.random(1, #buttons)]
            -- fire all click events
            for _, conn in ipairs(pick:GetConnections("MouseButton1Click") or {}) do
                pcall(function() conn:Fire() end)
            end
            for _, conn in ipairs(pick:GetConnections("Activated") or {}) do
                pcall(function() conn:Fire() end)
            end
            -- also try firesignal if available
            pcall(function()
                if firesignal then
                    firesignal(pick.MouseButton1Click)
                    firesignal(pick.Activated)
                end
            end)
        end
    end)
end

-- ========== MONSTERS FRAME ==========
local function monsterFrame(dt)
    local target = findAny()
    if not target then
        stopMov()
        clearPF()
        -- still press spawn button when dead/no target
        local now = tick()
        if now - lastSpawnPress >= 1 then
            pressSpawnButton()
            lastSpawnPress = now
        end
        return
    end

    local d = dist3d(LP, target)
    local now = tick()
    local h = hum(LP)

    -- press spawn button every 1 second
    if now - lastSpawnPress >= 1 then
        pressSpawnButton()
        lastSpawnPress = now
    end

    -- track damage: if health dropped, reset no-damage timer
    if h then
        local hp = h.Health
        if monsterLastHP and hp < monsterLastHP then
            monsterNoDmgStart = now
        end
        monsterLastHP = hp
    end

    -- alive without taking damage for 20s: click
    if monsterNoDmgStart and (now - monsterNoDmgStart >= MONSTER_NODMG_TIME) then
        click()
        monsterNoDmgStart = now
    end

    -- within 30 studs of human: auto click
    if d <= MONSTER_CLICK_RANGE then
        face(target)
        click()
    end

    -- idle 5s (XZ only): click
    if checkIdle(dt) then
        click()
    end

    tryJump()

    local tpos = predict(target) or (root(target) and root(target).Position)
    if tpos then
        goTo(tpos, target)
    end
end

-- ========== HUMANS FRAME ==========
local function humanFrame(dt)
    local s = S()
    local detectRadius = s.DetectRadius or HUMAN_DETECT_RANGE
    local now = tick()

    local target = nil

    -- target memory
    if s.TargetMemory and memoryTarget then
        if alive(memoryTarget) and isMonster(memoryTarget) then
            if dist3d(LP, memoryTarget) <= detectRadius * 3 then
                target = memoryTarget
            else
                memoryTarget = nil
            end
        else
            memoryTarget = nil
        end
    end

    if not target then
        target = findInRadius(detectRadius)
    end

    -- no target in radius
    if not target then
        local wp = s.Waypoint
        if wp then
            local d = distPos(LP, wp)
            if d > 3 then
                tryJump()
                goTo(wp, "waypoint")
            else
                stopMov()
                clearPF()
            end
        else
            target = findAny()
            if not target then
                stopMov()
                clearPF()
                if checkIdle(dt) then click() end
                return
            end
        end
    end

    if not target then
        if checkIdle(dt) then click() end
        return
    end

    -- press "1" once when monster first detected
    if not pressedOne then
        tapKey(Enum.KeyCode.One)
        pressedOne = true
    end

    if s.TargetMemory then
        memoryTarget = target
    end

    local d = dist3d(LP, target)

    -- anti-back
    if s.AntiBack and movingAway(target) then
        local a, b = root(LP), root(target)
        if a and b then
            local flat = Vector3.new(a.Position.X - b.Position.X, 0, a.Position.Z - b.Position.Z)
            if flat.Magnitude > 0.1 then
                moveTo(a.Position + flat.Unit * 5)
            end
        end
        tryJump()
        if checkIdle(dt) then click() end
        return
    end

    -- attack: 30cps
    if d <= 4 then
        face(target)
        local interval = 1 / HUMAN_CPS
        if now - lastClickTime >= interval then
            click()
            lastClickTime = now
        end
    end

    -- idle click
    if checkIdle(dt) then
        click()
    end

    tryJump()
    local tpos = predict(target) or (root(target) and root(target).Position)
    if tpos then
        goTo(tpos, target)
    end
end

-- ========== MAIN ==========
local function repairAllTools()
    pcall(function()
        local remotes = game:GetService("ReplicatedStorage"):WaitForChild("Remotes", 5)
        if not remotes then return end
        local shopInteract = remotes:WaitForChild("ShopInteract", 5)
        if not shopInteract then return end
        for _, toolName in ipairs(REPAIR_TOOLS) do
            pcall(function()
                shopInteract:InvokeServer("Repair", toolName)
            end)
        end
    end)
end

local function onDeath()
    -- reset "1" key press so it fires again next life
    pressedOne = false
    memoryTarget = nil
    monsterNoDmgStart = nil
    idleTimer = 0

    -- repair tools 5 seconds after death
    task.delay(5, function()
        if running then
            repairAllTools()
        end
    end)
end

local function hookCharacter(char)
    if not char then return end
    local humanoid = char:WaitForChild("Humanoid", 10)
    if not humanoid then return end

    if deathConn then pcall(function() deathConn:Disconnect() end) end
    deathConn = humanoid.Died:Connect(function()
        onDeath()
    end)
end

local function setupCharacterHook()
    -- hook current character
    if LP.Character then
        hookCharacter(LP.Character)
    end

    -- hook future characters
    if charConn then pcall(function() charConn:Disconnect() end) end
    charConn = LP.CharacterAdded:Connect(function(char)
        hookCharacter(char)
    end)
end

local function onFrame(dt)
    if not running then return end
    if not alive(LP) then
        monsterNoDmgStart = tick()
        idleTimer = 0
        return
    end

    local my = team(LP)
    if my == "Humans" then updateCircle() else destroyCircle() end
    if my == "Monsters" then monsterFrame(dt)
    elseif my == "Humans" then humanFrame(dt) end
end

-- ========== START / STOP ==========
local function startFarm()
    if running then return end
    running = true

    local h = hum(LP)
    if h then
        h.JumpHeight = JUMP_H
        h.UseJumpPower = false
        monsterLastHP = h.Health
    end

    lastJump = tick()
    lastClickTime = tick()
    monsterNoDmgStart = tick()
    lastSpawnPress = 0
    memoryTarget = nil
    pressedOne = false
    idleXZ = nil
    idleTimer = 0
    clearPF()

    setupCharacterHook()

    heartbeatConn = RunService.Heartbeat:Connect(onFrame)
    print("[AutoFarm] ON - " .. tostring(team(LP)))
end

local function stopFarm()
    -- set flag first so onFrame exits immediately
    running = false

    -- disconnect
    if heartbeatConn then
        pcall(function() heartbeatConn:Disconnect() end)
        heartbeatConn = nil
    end

    -- cleanup
    clearPF()
    destroyCircle()
    pcall(function() stopMov() end)

    -- disconnect death hooks
    if deathConn then pcall(function() deathConn:Disconnect() end) deathConn = nil end
    if charConn then pcall(function() charConn:Disconnect() end) charConn = nil end

    -- reset
    monsterNoDmgStart = nil
    monsterLastHP = nil
    memoryTarget = nil
    pressedOne = false
    idleXZ = nil
    idleTimer = 0

    print("[AutoFarm] OFF")
end

local function setWP()
    local r = root(LP)
    if not r then return end
    local s = S()
    s.Waypoint = r.Position
    getgenv().AutoFarmSettings = s
    print("[AutoFarm] Waypoint set")
end

local function removeWP()
    local s = S()
    s.Waypoint = nil
    getgenv().AutoFarmSettings = s
    print("[AutoFarm] Waypoint removed")
end

-- kill old instance if re-executed
if getgenv().AutoFarmControl and getgenv().AutoFarmControl.IsRunning() then
    pcall(function() getgenv().AutoFarmControl.Stop() end)
    task.wait(0.1)
end

getgenv().AutoFarmControl = {
    Start = startFarm,
    Stop = stopFarm,
    SetWaypoint = setWP,
    RemoveWaypoint = removeWP,
    IsRunning = function() return running end
}

if getgenv().AutoFarmSettings and getgenv().AutoFarmSettings.Enabled then
    startFarm()
end

print("[AutoFarm] Loaded")
return getgenv().AutoFarmControl
