-- AutoFarm
-- Monsters team -> hunt Humans, attack at 7 studs
-- Humans team -> hunt Monsters, attack at 4 studs until dead
-- Direct follow within 20 studs, pathfind beyond
-- Velocity prediction, jump every 1s, anti-stuck click

local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local LP = Players.LocalPlayer

-- ========== CONFIG ==========
local MONSTER_ATK_RANGE = 7
local HUMAN_ATK_RANGE = 4
local DIRECT_RANGE = 20
local JUMP_EVERY = 1
local STUCK_TIME = 3
local STUCK_DIST = 1
local PREDICT = 0.3
local Y_PENALTY = 3
local MAX_Y = 50
local JUMP_H = 8.5
local MAX_OBSTACLE = 9

-- ========== STATE ==========
local running = false
local lastJump = 0
local stuckStart = nil
local lastPos = nil

-- ========== RAYCAST ==========
local rayP = RaycastParams.new()
rayP.FilterType = Enum.RaycastFilterType.Exclude

local function refreshRay()
    local list = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Character then list[#list + 1] = p.Character end
    end
    rayP.FilterDescendantsInstances = list
end

-- ========== HELPERS ==========
local function root(p)
    local c = p.Character
    return c and c:FindFirstChild("HumanoidRootPart")
end

local function hum(p)
    local c = p.Character
    return c and c:FindFirstChildOfClass("Humanoid")
end

local function alive(p)
    local h = hum(p)
    return h and h.Health > 0
end

local function team(p)
    return p.Team and p.Team.Name
end

local function enemy(p)
    if p == LP then return false end
    local my = team(LP)
    local their = team(p)
    if my == "Monsters" and their == "Humans" then return true end
    if my == "Humans" and their == "Monsters" then return true end
    return false
end

local function dist(p)
    local a, b = root(LP), root(p)
    if not a or not b then return math.huge end
    return (a.Position - b.Position).Magnitude
end

local function score(p)
    local a, b = root(LP), root(p)
    if not a or not b then return math.huge end
    local d = a.Position - b.Position
    local horiz = math.sqrt(d.X * d.X + d.Z * d.Z)
    local vert = math.abs(d.Y)
    if vert > MAX_Y then return math.huge end
    return horiz + vert * Y_PENALTY
end

local function atkRange()
    return team(LP) == "Monsters" and MONSTER_ATK_RANGE or HUMAN_ATK_RANGE
end

local function findTarget()
    local best, bestS = nil, math.huge
    for _, p in ipairs(Players:GetPlayers()) do
        if enemy(p) and alive(p) then
            local s = score(p)
            if s < bestS then
                best, bestS = p, s
            end
        end
    end
    return best
end

local function predict(p)
    local r = root(p)
    if not r then return nil end
    local v = r.AssemblyLinearVelocity
    return r.Position + Vector3.new(v.X, 0, v.Z) * PREDICT
end

local function press()
    pcall(function()
        mouse1press()
        task.defer(function()
            mouse1release()
        end)
    end)
end

-- ========== MOVEMENT ==========
local function moveTo(pos)
    local h = hum(LP)
    if h then h:MoveTo(pos) end
end

local function stop()
    local h = hum(LP)
    local r = root(LP)
    if h and r then h:MoveTo(r.Position) end
end

local function face(target)
    local a, b = root(LP), root(target)
    if not a or not b then return end
    local d = (b.Position - a.Position)
    local flat = Vector3.new(d.X, 0, d.Z)
    if flat.Magnitude < 0.1 then return end
    a.CFrame = CFrame.lookAt(a.Position, a.Position + flat.Unit)
end

local function jump()
    local h = hum(LP)
    if not h then return end
    h.JumpHeight = JUMP_H
    h.Jump = true
end

local function tryJump()
    local now = tick()
    if now - lastJump >= JUMP_EVERY then
        jump()
        lastJump = now
    end
end

-- ========== OBSTACLE ==========
local function obstacleHeight()
    local r = root(LP)
    if not r then return 0 end
    refreshRay()
    local foot = r.Position - Vector3.new(0, 2.5, 0)
    local fwd = r.CFrame.LookVector * 4
    if not workspace:Raycast(foot, fwd, rayP) then return 0 end
    for h = 1, 16 do
        if not workspace:Raycast(foot + Vector3.new(0, h, 0), fwd, rayP) then
            return h
        end
    end
    return 99
end

local function sidestep()
    local r = root(LP)
    local h = hum(LP)
    if not r or not h then return end
    refreshRay()
    local rHit = workspace:Raycast(r.Position, r.CFrame.RightVector * 6, rayP)
    local lHit = workspace:Raycast(r.Position, -r.CFrame.RightVector * 6, rayP)
    if not rHit then
        h:MoveTo(r.Position + r.CFrame.RightVector * 5)
    elseif not lHit then
        h:MoveTo(r.Position - r.CFrame.RightVector * 5)
    else
        jump()
    end
    task.wait(0.3)
end

local function handleObstacle()
    local h = obstacleHeight()
    if h >= 2 and h <= MAX_OBSTACLE then
        jump()
        return true
    elseif h > MAX_OBSTACLE then
        sidestep()
        return true
    end
    return false
end

-- ========== STUCK DETECTION ==========
local function updateStuck()
    local r = root(LP)
    if not r then return end
    local pos = r.Position
    local now = tick()

    if lastPos and (pos - lastPos).Magnitude < STUCK_DIST then
        if not stuckStart then
            stuckStart = now
        elseif now - stuckStart >= STUCK_TIME then
            press()
            stuckStart = now -- reset after click
        end
    else
        stuckStart = nil
    end

    lastPos = pos
end

-- ========== PATHFIND ==========
local function pathTo(targetPos)
    local r = root(LP)
    if not r then return nil, nil end
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = false,
        WaypointSpacing = 3
    })
    local ok = pcall(function()
        path:ComputeAsync(r.Position, targetPos)
    end)
    if not ok or path.Status ~= Enum.PathStatus.Success then
        return nil, path
    end
    return path:GetWaypoints(), path
end

local function walkWaypoints(waypoints, path, target)
    local range = atkRange()

    local blocked = false
    local conn = path.Blocked:Connect(function()
        blocked = true
    end)

    for i = 2, #waypoints do
        if not running then break end
        if not alive(LP) then break end
        if not alive(target) then break end
        if blocked then break end

        local d = dist(target)
        if d <= range then break end
        if d <= DIRECT_RANGE then break end

        -- better target check
        local nt = findTarget()
        if nt and nt ~= target and score(nt) < score(target) - 10 then
            break
        end

        local wp = waypoints[i]

        -- pathfinder says jump
        if wp.Action == Enum.PathWaypointAction.Jump then
            jump()
        end

        -- obstacle check
        if handleObstacle() then
            break -- repath after obstacle handling
        end

        moveTo(wp.Position)

        -- walk to waypoint
        local t = 0
        while running and t < 1.5 do
            local r = root(LP)
            if not r then break end
            if (r.Position - wp.Position).Magnitude < 3 then break end
            if dist(target) <= range then break end
            if dist(target) <= DIRECT_RANGE then break end
            if blocked then break end

            tryJump()
            updateStuck()

            task.wait(0.01)
            t = t + 0.01
        end
    end

    pcall(function() conn:Disconnect() end)
end

-- ========== MAIN ==========
local function loop()
    lastJump = tick()
    stuckStart = nil
    lastPos = root(LP) and root(LP).Position

    while running do
        if not alive(LP) then
            stuckStart = nil
            task.wait(0.5)
            continue
        end

        local target = findTarget()
        if not target then
            stop()
            stuckStart = nil
            task.wait(0.1)
            continue
        end

        local d = dist(target)
        local range = atkRange()

        updateStuck()

        -- ====== ATTACK ======
        if d <= range then
            face(target)
            press()
            -- humans: keep hitting same monster
            if team(LP) == "Humans" then
                while running and alive(LP) and alive(target) and dist(target) <= range do
                    face(target)
                    press()
                    tryJump()
                    updateStuck()
                    task.wait(0.01)
                end
            end
            task.wait(0.01)
            continue
        end

        -- ====== DIRECT FOLLOW (within 20) ======
        if d <= DIRECT_RANGE then
            local pos = predict(target)
            if pos then
                moveTo(pos)
            end
            tryJump()
            handleObstacle()
            task.wait(0.01)
            continue
        end

        -- ====== PATHFIND (beyond 20) ======
        local tpos = predict(target) or (root(target) and root(target).Position)
        if not tpos then
            task.wait(0.1)
            continue
        end

        local waypoints, path = pathTo(tpos)

        if waypoints then
            walkWaypoints(waypoints, path, target)
        else
            -- fallback: direct move
            moveTo(tpos)
            handleObstacle()
            task.wait(0.1)
        end

        task.wait(0.01)
    end
end

-- ========== CONTROL ==========
local function startFarm()
    if running then return end
    running = true
    local h = hum(LP)
    if h then
        h.JumpHeight = JUMP_H
        h.UseJumpPower = false
    end
    task.spawn(loop)
    print("[AutoFarm] ON - " .. tostring(team(LP)))
end

local function stopFarm()
    running = false
    stop()
    stuckStart = nil
    lastPos = nil
    print("[AutoFarm] OFF")
end

getgenv().AutoFarmControl = {
    Start = startFarm,
    Stop = stopFarm,
    IsRunning = function() return running end
}

if getgenv().AutoFarmSettings and getgenv().AutoFarmSettings.Enabled then
    startFarm()
end

print("[AutoFarm] trytry5rtyhythyty65tr")
return getgenv().AutoFarmControl
